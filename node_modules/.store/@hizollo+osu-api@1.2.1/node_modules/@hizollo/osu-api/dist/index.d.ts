import { Buffer } from 'node:buffer';

type ModsResolvable = number | string | bigint | ModsBitField | Array<ModsResolvable>;
declare class ModsBitField {
    static Flags: {
        None: bigint;
        NoFail: bigint;
        Easy: bigint;
        TouchDevice: bigint;
        Hidden: bigint;
        HardRock: bigint;
        SuddenDeath: bigint;
        DoubleTime: bigint;
        Relax: bigint;
        HalfTime: bigint;
        Nightcore: bigint;
        Flashlight: bigint;
        Autoplay: bigint;
        SpunOut: bigint;
        AutoPilot: bigint;
        Perfect: bigint;
        Key4: bigint;
        Key5: bigint;
        Key6: bigint;
        Key7: bigint;
        Key8: bigint;
        FadeIn: bigint;
        Random: bigint;
        Cinema: bigint;
        Target: bigint;
        Key9: bigint;
        KeyCoop: bigint;
        Key1: bigint;
        Key3: bigint;
        Key2: bigint;
        ScoreV2: bigint;
        Mirror: bigint;
    };
    static KeyMod: bigint;
    static FreeModAllowed: bigint;
    static ScoreIncreaseMods: bigint;
    bitfield: bigint;
    constructor(bits?: ModsResolvable);
    any(bit: ModsResolvable): boolean;
    equals(bit: ModsResolvable): boolean;
    has(bit: ModsResolvable): boolean;
    add(...bits: Array<ModsResolvable>): this;
    remove(...bits: ModsResolvable[]): this;
    toArray(): string[];
    serialize(): {
        [key: string]: boolean;
    };
    isNone(): boolean;
    valueOf(): bigint;
    static resolve(bit: ModsResolvable): bigint;
}

declare enum GameMode {
    Standard = 0,
    Taiko = 1,
    Catch = 2,
    Mania = 3
}
declare enum UserRequestType {
    String = "string",
    Id = "id"
}
declare const Mods: {
    None: bigint;
    NoFail: bigint;
    Easy: bigint;
    TouchDevice: bigint;
    Hidden: bigint;
    HardRock: bigint;
    SuddenDeath: bigint;
    DoubleTime: bigint;
    Relax: bigint;
    HalfTime: bigint;
    Nightcore: bigint;
    Flashlight: bigint;
    Autoplay: bigint;
    SpunOut: bigint;
    AutoPilot: bigint;
    Perfect: bigint;
    Key4: bigint;
    Key5: bigint;
    Key6: bigint;
    Key7: bigint;
    Key8: bigint;
    FadeIn: bigint;
    Random: bigint;
    Cinema: bigint;
    Target: bigint;
    Key9: bigint;
    KeyCoop: bigint;
    Key1: bigint;
    Key3: bigint;
    Key2: bigint;
    ScoreV2: bigint;
    Mirror: bigint;
};
declare const ModsAbbreviation: {
    NoFail: string;
    Easy: string;
    TouchDevice: string;
    Hidden: string;
    HardRock: string;
    SuddenDeath: string;
    DoubleTime: string;
    Relax: string;
    HalfTime: string;
    Nightcore: string;
    Flashlight: string;
    Autoplay: string;
    SpunOut: string;
    AutoPilot: string;
    Perfect: string;
    Key4: string;
    Key5: string;
    Key6: string;
    Key7: string;
    Key8: string;
    FadeIn: string;
    Random: string;
    Cinema: string;
    Target: string;
    Key9: string;
    KeyCoop: string;
    Key1: string;
    Key3: string;
    Key2: string;
    ScoreV2: string;
    Mirror: string;
};
declare enum BeatmapApprovedState {
    Graveyard = -2,
    WIP = -1,
    Pending = 0,
    Ranked = 1,
    Approved = 2,
    Qualified = 3,
    Loved = 4
}
declare enum BeatmapGenre {
    Any = 0,
    Unspecified = 1,
    VideoGame = 2,
    Anime = 3,
    Rock = 4,
    Pop = 5,
    Other = 6,
    Novelty = 7,
    HipHop = 9,
    Electronic = 10,
    Metal = 11,
    Classic = 12,
    Folk = 13,
    Jazz = 14
}
declare enum BeatmapLanguage {
    Any = 0,
    Unspecified = 1,
    English = 2,
    Japanese = 3,
    Chinese = 4,
    Instrumental = 5,
    Korean = 6,
    French = 7,
    German = 8,
    Swedish = 9,
    Spanish = 10,
    Italian = 11,
    Russian = 12,
    Polish = 13,
    Other = 14
}
declare enum ScoreRank {
    XH = 0,
    X = 1,
    SH = 2,
    S = 3,
    A = 4,
    B = 5,
    C = 6,
    D = 7,
    F = 8
}
declare enum MatchScoringType {
    Score = 0,
    Accuracy = 1,
    Combo = 2,
    ScoreV2 = 3
}
declare enum MatchTeamType {
    HeadToHead = 0,
    TagCoop = 1,
    TeamVs = 2,
    TagTeamVs = 3
}
declare enum Team {
    None = 0,
    Blue = 1,
    Red = 2
}

interface ClientOptions {
    apiKey: string;
}
interface FetchUserBannerOptions {
    id: string;
}
interface UserScoreRankCount {
    ssh: number;
    ss: number;
    sh: number;
    s: number;
    a: number;
}
interface BeatmapDiffculty {
    ApproachRate: number;
    CircleSize: number;
    HPDrainRate: number;
    OverallDifficulty: number;
    aim: number | null;
    speed: number | null;
    rating: number;
}
interface BeatmapObjectCount {
    circle: number;
    slider: number;
    spinner: number;
}
interface ScoreStatistics {
    count50: number;
    count100: number;
    count300: number;
    countMiss: number;
    countKatu: number;
    countGeki: number;
}
interface RequestOptions<T extends OsuApiRequestOptions> {
    path: string;
    queries: T;
}
interface BeatmapScoreOtherInfo {
    mapId?: string;
    mode?: GameMode;
}
interface OsuApiRequestOptions {
}
interface APIGetUserRequestOptions extends OsuApiRequestOptions {
    u: string;
    m?: GameMode;
    type?: UserRequestType;
    event_days?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31;
}
interface GetUserRequestOptions {
    user: string;
    gameMode?: GameMode;
    type?: UserRequestType;
    eventDays?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31;
}
interface APIGetBeatmapsRequestOptions extends OsuApiRequestOptions {
    since?: string;
    s?: string;
    b?: string;
    u?: string;
    type?: UserRequestType;
    m?: GameMode;
    a?: boolean;
    h?: string;
    limit?: number;
    mods?: bigint;
}
interface GetBeatmapsRequestOptions {
    since?: Date;
    beatmapsetId?: string;
    beatmapId?: string;
    user?: string;
    type?: UserRequestType;
    mode?: GameMode;
    showConverted?: boolean;
    hash?: string;
    limit?: number;
    mods?: ModsResolvable;
}
interface APIGetScoresRequestOptions extends OsuApiRequestOptions {
    b: string;
    u?: string;
    m?: GameMode;
    mods?: bigint;
    type?: UserRequestType;
    limit?: number;
}
interface GetScoreRequestOptions {
    beatmapId: string;
    user?: string;
    mode?: GameMode;
    mods?: ModsResolvable;
    type?: UserRequestType;
    limit?: number;
}
interface APIGetUserBestRequestOptions extends OsuApiRequestOptions {
    u: string;
    m?: GameMode;
    type?: UserRequestType;
    limit?: number;
}
interface GetUserBestRequestOptions {
    user: string;
    mode?: GameMode;
    type?: UserRequestType;
    limit?: number;
}
interface APIGetUserRecentRequestOptions extends OsuApiRequestOptions {
    u: string;
    m?: GameMode;
    type?: UserRequestType;
    limit?: number;
}
interface GetUserRecentRequestOptions {
    user: string;
    mode?: GameMode;
    type?: UserRequestType;
    limit?: number;
}
interface APIGetReplayRequestOptions extends OsuApiRequestOptions {
    b?: string;
    u?: string;
    m?: GameMode;
    s?: string;
    type?: UserRequestType;
    mods?: bigint;
}
interface GetReplayRequestOptions {
    beatmapId?: string;
    user?: string;
    mode?: GameMode;
    scoreId?: string;
    type?: UserRequestType;
    mods?: ModsResolvable;
}
interface APIGetMatchRequestOptions extends OsuApiRequestOptions {
    mp: string;
}
interface GetMatchRequestOptions {
    matchId: string;
}

interface APIUser {
    user_id: string;
    username: string;
    join_date: string;
    count300: string;
    count100: string;
    count50: string;
    playcount: string;
    ranked_score: string;
    total_score: string;
    pp_rank: string;
    level: string;
    pp_raw: string;
    accuracy: string;
    count_rank_ss: string;
    count_rank_ssh: string;
    count_rank_s: string;
    count_rank_sh: string;
    count_rank_a: string;
    country: string;
    total_seconds_played: string;
    pp_country_rank: string;
    events: Array<APIUserEvent>;
}
interface APIUserEvent {
    display_html: string;
    beatmap_id: string;
    beatmapset_id: string;
    date: string;
    epicfactor: string;
}
interface APIBeatmap {
    beatmapset_id: string;
    beatmap_id: string;
    approved: '-2' | '-1' | '0' | '1' | '2' | '3' | '4';
    total_length: string;
    hit_length: string;
    version: string;
    file_md5: string;
    diff_size: string;
    diff_overall: string;
    diff_approach: string;
    diff_drain: string;
    mode: string;
    count_normal: string;
    count_slider: string;
    count_spinner: string;
    submit_date: string;
    approved_date: string | null;
    last_update: string;
    artist: string;
    title: string;
    creator: string;
    creator_id: string;
    bpm: string;
    source: string;
    tags: string;
    genre_id: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '9' | '10' | '11' | '12' | '13' | '14';
    language_id: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14';
    favourite_count: string;
    rating: string;
    download_unavailable: '0' | '1';
    audio_unavailable: '0' | '1';
    playcount: string;
    passcount: string;
    max_combo: string | null;
    diff_aim: string | null;
    diff_speed: string | null;
    difficultyrating: string | null;
}
interface APIBasicScore {
    score: string;
    maxcombo: string;
    count50: string;
    count100: string;
    count300: string;
    countmiss: string;
    countkatu: string;
    countgeki: string;
    perfect: '0' | '1';
    enabled_mods: string;
    user_id: string;
    rank: keyof typeof ScoreRank;
}
interface APIUserRecentPlayedScore extends APIBasicScore {
    date: string;
    beatmap_id: string;
}
interface APIUserBestPerformanceScore extends APIUserRecentPlayedScore {
    score_id: string;
    pp: string;
    replay_available: '0' | '1';
}
interface APIBeatmapScore extends APIBasicScore {
    date: string;
    score_id: string;
    username: string;
    pp: string;
    replay_available: '0' | '1';
}
interface APIMatchScore extends APIBasicScore {
    slot: string;
    team: '0' | '1' | '2';
    pass: '0' | '1';
}
interface APIMatchData {
    match_id: string;
    name: string;
    start_time: string;
    end_time: string | null;
}
interface APIMatchGameData {
    game_id: string;
    start_time: string;
    end_time: string;
    beatmap_id: string;
    play_mode: '0' | '1' | '2' | '3';
    match_type: string;
    scoring_type: '0' | '1' | '2' | '3';
    team_type: '0' | '1' | '2' | '3';
    mods: string;
    scores: Array<APIMatchScore>;
}
interface APIMatch {
    match: APIMatchData;
    games: Array<APIMatchGameData>;
}
interface APIMatchNotFound {
    match: 0;
    games: [];
}
interface APIReplay {
    content: string;
    encoding: 'base64';
}

declare class Replay {
    readonly client: Client;
    readonly content: string;
    readonly stream: Buffer;
    constructor(client: Client, data: APIReplay);
}

declare class Beatmapset {
    readonly client: Client;
    readonly beatmaps: Array<Beatmap>;
    readonly id: string;
    readonly approvedState: BeatmapApprovedState;
    readonly length: number;
    readonly submitDate: Date;
    readonly approvedDate: Date | null;
    readonly lastUpdate: Date;
    readonly artist: string;
    readonly title: string;
    readonly creator: string;
    readonly creatorId: string;
    readonly source: string;
    readonly tags: string[];
    readonly genre: BeatmapGenre;
    readonly language: BeatmapLanguage;
    readonly favoriteCount: number;
    readonly rating: number;
    readonly downloadUnavailable: boolean;
    readonly audioUnavailable: boolean;
    constructor(client: Client, data: Beatmap, maps: Array<Beatmap>);
    beatmapsetURL(): string;
    coverImageURL(): string;
    coverThumbnailURL(): string;
    getCreator(): Promise<User | undefined>;
}

declare class UserEvent {
    readonly user: User;
    readonly displayHtml: string;
    readonly beatmapId: string;
    readonly beatmapsetId: string;
    readonly date: Date;
    readonly epicfactor: number;
    constructor(user: User, data: APIUserEvent);
    getBeatmap(): Promise<Beatmap | undefined>;
    getBeatmapset(): Promise<Beatmapset | undefined>;
}

declare class User {
    readonly client: Client;
    readonly id: string;
    readonly username: string;
    readonly joinDate: Date;
    readonly playcount: number;
    readonly level: number;
    readonly country: string;
    readonly playtime: number;
    readonly events: Array<UserEvent>;
    banner: string | null;
    readonly count300: number;
    readonly count100: number;
    readonly count50: number;
    readonly rankedScore: number;
    readonly totalScore: number;
    readonly rank: number;
    readonly countryRank: number;
    readonly pp: number;
    readonly accuracy: number;
    readonly scoreRankCount: UserScoreRankCount;
    constructor(client: Client, data: APIUser);
    avatarURL(): string;
    profileURL(): string;
    fetchBanner(force?: boolean): Promise<string>;
    getBest(options?: Omit<GetUserBestRequestOptions, "user" | "type">): Promise<BeatmapScore[]>;
    getRecent(options?: Omit<GetUserRecentRequestOptions, "user" | "type">): Promise<BeatmapScore[]>;
}

declare class Beatmap {
    readonly client: Client;
    readonly id: string;
    readonly beatmapsetId: string;
    readonly approvedState: BeatmapApprovedState;
    readonly totalLength: number;
    readonly hitLength: number;
    readonly diffcultyName: string;
    readonly hash: string;
    readonly difficulty: BeatmapDiffculty;
    readonly mode: GameMode;
    readonly objectCount: BeatmapObjectCount;
    readonly submitDate: Date;
    readonly approvedDate: Date | null;
    readonly lastUpdate: Date;
    readonly artist: string;
    readonly title: string;
    readonly creator: string;
    readonly creatorId: string;
    readonly bpm: number;
    readonly source: string;
    readonly tags: string[];
    readonly genre: BeatmapGenre;
    readonly language: BeatmapLanguage;
    readonly favoriteCount: number;
    readonly rating: number;
    readonly downloadUnavailable: boolean;
    readonly audioUnavailable: boolean;
    readonly playcount: number;
    readonly passcount: number;
    readonly maxCombo: number | null;
    constructor(client: Client, data: APIBeatmap);
    beatmapsetURL(): string;
    beatmapURL(): string;
    coverImageURL(): string;
    coverThumbnailURL(): string;
    getCreator(): Promise<User | undefined>;
    getBeatmapset(): Promise<Beatmapset>;
}

type APIScore = APIBasicScore | APIUserRecentPlayedScore | APIUserBestPerformanceScore | APIBeatmapScore | APIMatchScore;
declare abstract class BaseScore {
    readonly client: Client;
    readonly score: number;
    readonly maxCombo: number;
    readonly statistics: ScoreStatistics;
    readonly perfect: boolean;
    readonly enabledMods: ModsBitField;
    readonly userId: string;
    readonly rank: ScoreRank;
    readonly mode: GameMode;
    readonly beatmapId: string;
    readonly accuracy: number;
    constructor(client: Client, data: APIScore, other: BeatmapScoreOtherInfo);
    getPlayer(options?: Omit<GetUserRequestOptions, "user" | "type">): Promise<User | undefined>;
    getBeatmap(): Promise<Beatmap>;
    getReplay(): Promise<Replay>;
}

declare class BeatmapScore extends BaseScore {
    readonly date: Date;
    readonly scoreId: string | null;
    readonly username: string | null;
    readonly pp: number | null;
    readonly replayAvailable: boolean | null;
    constructor(client: Client, data: APIBeatmapScore, other: BeatmapScoreOtherInfo);
    constructor(client: Client, data: APIUserBestPerformanceScore, other: BeatmapScoreOtherInfo);
    constructor(client: Client, data: APIUserRecentPlayedScore, other: BeatmapScoreOtherInfo);
    scoreURL(): string | null;
}

declare abstract class BaseManager {
    readonly client: Client;
    constructor(client: Client);
}

declare class UserManager extends BaseManager {
    getUser(options: GetUserRequestOptions): Promise<User[]>;
    fetchBanner({ id }: FetchUserBannerOptions): Promise<string>;
    getUserBest(options: GetUserBestRequestOptions): Promise<BeatmapScore[]>;
    getUserRecent(options: GetUserRecentRequestOptions): Promise<BeatmapScore[]>;
}

declare class BeatmapManager extends BaseManager {
    getBeatmaps(options?: GetBeatmapsRequestOptions): Promise<Beatmap[]>;
}

declare class ScoreManager extends BaseManager {
    getScores(options: GetScoreRequestOptions): Promise<BeatmapScore[]>;
}

declare class ReplayManager extends BaseManager {
    getReplay(options: GetReplayRequestOptions): Promise<Replay>;
}

declare class MatchScore extends BaseScore {
    readonly slot: number;
    readonly team: Team;
    readonly pass: boolean;
    constructor(client: Client, data: APIMatchScore, other: BeatmapScoreOtherInfo);
}

declare class MatchGame {
    readonly client: Client;
    readonly match: Match;
    readonly id: string;
    readonly startAt: Date;
    readonly endAt: Date;
    readonly beatmapId: string;
    readonly mode: GameMode;
    readonly matchType: number;
    readonly scoringType: MatchScoringType;
    readonly teamType: Team;
    readonly mods: ModsBitField;
    readonly scores: Array<MatchScore>;
    constructor(match: Match, data: APIMatchGameData);
    getBeatmap(): Promise<Beatmap | undefined>;
}

declare class Match {
    readonly client: Client;
    readonly id: string;
    readonly name: string;
    readonly startAt: Date;
    readonly endAt: Date | null;
    readonly games: Array<MatchGame>;
    constructor(client: Client, data: APIMatch);
}

declare class MatchManager extends BaseManager {
    getMatch(options: GetMatchRequestOptions): Promise<Match | null>;
}

declare class Client {
    private apiKey;
    users: UserManager;
    beatmaps: BeatmapManager;
    scores: ScoreManager;
    replays: ReplayManager;
    matches: MatchManager;
    constructor(options: ClientOptions);
    request<T extends OsuApiRequestOptions>(options: RequestOptions<T>): Promise<any>;
}

declare abstract class URLBuilder {
    private static gameModeToURLPattern;
    static avatar(id: string): string;
    static profile(idOrName: string): string;
    static banner(userId: string, hash: string, ext: string): string;
    static defaultBanner(id: string, ext: string): string;
    static beatmapsetURL(beatmapsetId: string): string;
    static beatmapURL(beatmapsetId: string, beatmapId: string, mode: GameMode): string;
    static beatmapCoverImage(beatmapsetId: string): string;
    static beatmapCoverThumbnail(beatmapsetId: string): string;
    static scoreURL(mode: GameMode, scoreId: string): string;
}

declare abstract class AccuracyCalculator {
    static standard(count300: number, count100: number, count50: number, countMiss: number): number;
    static taiko(count300: number, count100: number, countMiss: number): number;
    static catch(count300: number, count100: number, count50: number, countKatu: number, countMiss: number): number;
    static mania(count300: number, count100: number, count50: number, countKatu: number, countGeki: number, countMiss: number): number;
    static maniaV2(count300: number, count100: number, count50: number, countKatu: number, countGeki: number, countMiss: number): number;
    static calculate(score: BaseScore, v2?: boolean): number;
}

export { APIBasicScore, APIBeatmap, APIBeatmapScore, APIGetBeatmapsRequestOptions, APIGetMatchRequestOptions, APIGetReplayRequestOptions, APIGetScoresRequestOptions, APIGetUserBestRequestOptions, APIGetUserRecentRequestOptions, APIGetUserRequestOptions, APIMatch, APIMatchData, APIMatchGameData, APIMatchNotFound, APIMatchScore, APIReplay, APIScore, APIUser, APIUserBestPerformanceScore, APIUserEvent, APIUserRecentPlayedScore, AccuracyCalculator, BaseManager, BaseScore, Beatmap, BeatmapApprovedState, BeatmapDiffculty, BeatmapGenre, BeatmapLanguage, BeatmapManager, BeatmapObjectCount, BeatmapScore, BeatmapScoreOtherInfo, Beatmapset, Client, ClientOptions, FetchUserBannerOptions, GameMode, GetBeatmapsRequestOptions, GetMatchRequestOptions, GetReplayRequestOptions, GetScoreRequestOptions, GetUserBestRequestOptions, GetUserRecentRequestOptions, GetUserRequestOptions, Match, MatchGame, MatchManager, MatchScore, MatchScoringType, MatchTeamType, Mods, ModsAbbreviation, ModsBitField, ModsResolvable, OsuApiRequestOptions, Replay, ReplayManager, RequestOptions, ScoreManager, ScoreRank, ScoreStatistics, Team, URLBuilder, User, UserEvent, UserManager, UserRequestType, UserScoreRankCount };
