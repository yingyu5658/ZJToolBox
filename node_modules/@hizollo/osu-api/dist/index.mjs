// src/Client.ts
import request2 from "superagent";

// src/managers/UserManager.ts
import request from "superagent";

// src/types/enums.ts
var GameMode = /* @__PURE__ */ ((GameMode3) => {
  GameMode3[GameMode3["Standard"] = 0] = "Standard";
  GameMode3[GameMode3["Taiko"] = 1] = "Taiko";
  GameMode3[GameMode3["Catch"] = 2] = "Catch";
  GameMode3[GameMode3["Mania"] = 3] = "Mania";
  return GameMode3;
})(GameMode || {});
var UserRequestType = /* @__PURE__ */ ((UserRequestType2) => {
  UserRequestType2["String"] = "string";
  UserRequestType2["Id"] = "id";
  return UserRequestType2;
})(UserRequestType || {});
var Mods = {
  None: 0n,
  NoFail: 1n << 0n,
  Easy: 1n << 1n,
  TouchDevice: 1n << 2n,
  Hidden: 1n << 3n,
  HardRock: 1n << 4n,
  SuddenDeath: 1n << 5n,
  DoubleTime: 1n << 6n,
  Relax: 1n << 7n,
  HalfTime: 1n << 8n,
  Nightcore: 1n << 9n,
  Flashlight: 1n << 10n,
  Autoplay: 1n << 11n,
  SpunOut: 1n << 12n,
  AutoPilot: 1n << 13n,
  Perfect: 1n << 14n,
  Key4: 1n << 15n,
  Key5: 1n << 16n,
  Key6: 1n << 17n,
  Key7: 1n << 18n,
  Key8: 1n << 19n,
  FadeIn: 1n << 20n,
  Random: 1n << 21n,
  Cinema: 1n << 22n,
  Target: 1n << 23n,
  Key9: 1n << 24n,
  KeyCoop: 1n << 25n,
  Key1: 1n << 26n,
  Key3: 1n << 27n,
  Key2: 1n << 28n,
  ScoreV2: 1n << 29n,
  Mirror: 1n << 30n
};
var ModsAbbreviation = {
  NoFail: "NF",
  Easy: "EZ",
  TouchDevice: "TD",
  Hidden: "HD",
  HardRock: "HR",
  SuddenDeath: "SD",
  DoubleTime: "DT",
  Relax: "RX",
  HalfTime: "HT",
  Nightcore: "NC",
  Flashlight: "FL",
  Autoplay: "AT",
  SpunOut: "SO",
  AutoPilot: "AP",
  Perfect: "PF",
  Key4: "4K",
  Key5: "5K",
  Key6: "6K",
  Key7: "7K",
  Key8: "8K",
  FadeIn: "FI",
  Random: "RD",
  Cinema: "CM",
  Target: "TP",
  Key9: "9K",
  KeyCoop: "CP",
  Key1: "1K",
  Key3: "3K",
  Key2: "2K",
  ScoreV2: "SV2",
  Mirror: "MR"
};
var BeatmapApprovedState = /* @__PURE__ */ ((BeatmapApprovedState3) => {
  BeatmapApprovedState3[BeatmapApprovedState3["Graveyard"] = -2] = "Graveyard";
  BeatmapApprovedState3[BeatmapApprovedState3["WIP"] = -1] = "WIP";
  BeatmapApprovedState3[BeatmapApprovedState3["Pending"] = 0] = "Pending";
  BeatmapApprovedState3[BeatmapApprovedState3["Ranked"] = 1] = "Ranked";
  BeatmapApprovedState3[BeatmapApprovedState3["Approved"] = 2] = "Approved";
  BeatmapApprovedState3[BeatmapApprovedState3["Qualified"] = 3] = "Qualified";
  BeatmapApprovedState3[BeatmapApprovedState3["Loved"] = 4] = "Loved";
  return BeatmapApprovedState3;
})(BeatmapApprovedState || {});
var BeatmapGenre = /* @__PURE__ */ ((BeatmapGenre3) => {
  BeatmapGenre3[BeatmapGenre3["Any"] = 0] = "Any";
  BeatmapGenre3[BeatmapGenre3["Unspecified"] = 1] = "Unspecified";
  BeatmapGenre3[BeatmapGenre3["VideoGame"] = 2] = "VideoGame";
  BeatmapGenre3[BeatmapGenre3["Anime"] = 3] = "Anime";
  BeatmapGenre3[BeatmapGenre3["Rock"] = 4] = "Rock";
  BeatmapGenre3[BeatmapGenre3["Pop"] = 5] = "Pop";
  BeatmapGenre3[BeatmapGenre3["Other"] = 6] = "Other";
  BeatmapGenre3[BeatmapGenre3["Novelty"] = 7] = "Novelty";
  BeatmapGenre3[BeatmapGenre3["HipHop"] = 9] = "HipHop";
  BeatmapGenre3[BeatmapGenre3["Electronic"] = 10] = "Electronic";
  BeatmapGenre3[BeatmapGenre3["Metal"] = 11] = "Metal";
  BeatmapGenre3[BeatmapGenre3["Classic"] = 12] = "Classic";
  BeatmapGenre3[BeatmapGenre3["Folk"] = 13] = "Folk";
  BeatmapGenre3[BeatmapGenre3["Jazz"] = 14] = "Jazz";
  return BeatmapGenre3;
})(BeatmapGenre || {});
var BeatmapLanguage = /* @__PURE__ */ ((BeatmapLanguage3) => {
  BeatmapLanguage3[BeatmapLanguage3["Any"] = 0] = "Any";
  BeatmapLanguage3[BeatmapLanguage3["Unspecified"] = 1] = "Unspecified";
  BeatmapLanguage3[BeatmapLanguage3["English"] = 2] = "English";
  BeatmapLanguage3[BeatmapLanguage3["Japanese"] = 3] = "Japanese";
  BeatmapLanguage3[BeatmapLanguage3["Chinese"] = 4] = "Chinese";
  BeatmapLanguage3[BeatmapLanguage3["Instrumental"] = 5] = "Instrumental";
  BeatmapLanguage3[BeatmapLanguage3["Korean"] = 6] = "Korean";
  BeatmapLanguage3[BeatmapLanguage3["French"] = 7] = "French";
  BeatmapLanguage3[BeatmapLanguage3["German"] = 8] = "German";
  BeatmapLanguage3[BeatmapLanguage3["Swedish"] = 9] = "Swedish";
  BeatmapLanguage3[BeatmapLanguage3["Spanish"] = 10] = "Spanish";
  BeatmapLanguage3[BeatmapLanguage3["Italian"] = 11] = "Italian";
  BeatmapLanguage3[BeatmapLanguage3["Russian"] = 12] = "Russian";
  BeatmapLanguage3[BeatmapLanguage3["Polish"] = 13] = "Polish";
  BeatmapLanguage3[BeatmapLanguage3["Other"] = 14] = "Other";
  return BeatmapLanguage3;
})(BeatmapLanguage || {});
var ScoreRank = /* @__PURE__ */ ((ScoreRank2) => {
  ScoreRank2[ScoreRank2["XH"] = 0] = "XH";
  ScoreRank2[ScoreRank2["X"] = 1] = "X";
  ScoreRank2[ScoreRank2["SH"] = 2] = "SH";
  ScoreRank2[ScoreRank2["S"] = 3] = "S";
  ScoreRank2[ScoreRank2["A"] = 4] = "A";
  ScoreRank2[ScoreRank2["B"] = 5] = "B";
  ScoreRank2[ScoreRank2["C"] = 6] = "C";
  ScoreRank2[ScoreRank2["D"] = 7] = "D";
  ScoreRank2[ScoreRank2["F"] = 8] = "F";
  return ScoreRank2;
})(ScoreRank || {});
var MatchScoringType = /* @__PURE__ */ ((MatchScoringType2) => {
  MatchScoringType2[MatchScoringType2["Score"] = 0] = "Score";
  MatchScoringType2[MatchScoringType2["Accuracy"] = 1] = "Accuracy";
  MatchScoringType2[MatchScoringType2["Combo"] = 2] = "Combo";
  MatchScoringType2[MatchScoringType2["ScoreV2"] = 3] = "ScoreV2";
  return MatchScoringType2;
})(MatchScoringType || {});
var MatchTeamType = /* @__PURE__ */ ((MatchTeamType2) => {
  MatchTeamType2[MatchTeamType2["HeadToHead"] = 0] = "HeadToHead";
  MatchTeamType2[MatchTeamType2["TagCoop"] = 1] = "TagCoop";
  MatchTeamType2[MatchTeamType2["TeamVs"] = 2] = "TeamVs";
  MatchTeamType2[MatchTeamType2["TagTeamVs"] = 3] = "TagTeamVs";
  return MatchTeamType2;
})(MatchTeamType || {});
var Team = /* @__PURE__ */ ((Team2) => {
  Team2[Team2["None"] = 0] = "None";
  Team2[Team2["Blue"] = 1] = "Blue";
  Team2[Team2["Red"] = 2] = "Red";
  return Team2;
})(Team || {});

// src/utils/URLBuilder.ts
var URLBuilder = class {
  static gameModeToURLPattern(mode) {
    switch (mode) {
      case 0 /* Standard */:
        return "osu";
      case 1 /* Taiko */:
        return "taiko";
      case 2 /* Catch */:
        return "fruits";
      case 3 /* Mania */:
        return "mania";
      default:
        throw new Error("INVALID_GAMEMODE");
    }
  }
  static avatar(id) {
    return `https://a.ppy.sh/${id}`;
  }
  static profile(idOrName) {
    return `https://osu.ppy.sh/users/${idOrName}`;
  }
  static banner(userId, hash, ext) {
    return `https://assets.ppy.sh/user-profile-covers/${userId}/${hash}.${ext}`;
  }
  static defaultBanner(id, ext) {
    return `https://osu.ppy.sh/images/headers/profile-covers/c${id}.${ext}`;
  }
  static beatmapsetURL(beatmapsetId) {
    return `https://osu.ppy.sh/beatmapsets/${beatmapsetId}`;
  }
  static beatmapURL(beatmapsetId, beatmapId, mode) {
    const m = URLBuilder.gameModeToURLPattern(mode);
    return `https://osu.ppy.sh/beatmapsets/${beatmapsetId}#${m}/${beatmapId}`;
  }
  static beatmapCoverImage(beatmapsetId) {
    return `https://assets.ppy.sh/beatmaps/${beatmapsetId}/covers/cover.jpg`;
  }
  static beatmapCoverThumbnail(beatmapsetId) {
    return `https://b.ppy.sh/thumb/${beatmapsetId}l.jpg`;
  }
  static scoreURL(mode, scoreId) {
    const m = URLBuilder.gameModeToURLPattern(mode);
    return `https://osu.ppy.sh/scores/${m}/${scoreId}`;
  }
};

// src/structures/ModsBitField.ts
var _ModsBitField = class {
  constructor(bits = 0n) {
    this.bitfield = _ModsBitField.resolve(bits);
  }
  any(bit) {
    return (this.bitfield & _ModsBitField.resolve(bit)) !== 0n;
  }
  equals(bit) {
    return this.bitfield === _ModsBitField.resolve(bit);
  }
  has(bit) {
    bit = _ModsBitField.resolve(bit);
    return (this.bitfield & bit) === bit;
  }
  add(...bits) {
    let total = 0n;
    for (const bit of bits) {
      total |= _ModsBitField.resolve(bit);
    }
    this.bitfield |= total;
    return this;
  }
  remove(...bits) {
    let total = 0n;
    for (const bit of bits) {
      total |= _ModsBitField.resolve(bit);
    }
    this.bitfield &= ~total;
    return this;
  }
  toArray() {
    return Object.keys(_ModsBitField.Flags).filter((bit) => this.has(bit));
  }
  serialize() {
    const serialized = {};
    for (const [flag, bit] of Object.entries(_ModsBitField.Flags)) {
      serialized[flag] = this.has(bit);
    }
    return serialized;
  }
  isNone() {
    return this.bitfield === 0n;
  }
  valueOf() {
    return this.bitfield;
  }
  static resolve(bit) {
    if (Array.isArray(bit)) {
      return bit.map(_ModsBitField.resolve).reduce((acc, now) => acc | now, 0n);
    }
    if (bit instanceof _ModsBitField) {
      return bit.bitfield;
    }
    if (typeof bit === "number")
      return BigInt(bit);
    if (typeof bit === "string") {
      if (!isNaN(+bit))
        return BigInt(bit);
      const a = _ModsBitField.Flags[bit];
      if (typeof a === "undefined")
        throw new Error("INVALID_BITFIELD");
      return a;
    }
    return bit;
  }
};
var ModsBitField = _ModsBitField;
ModsBitField.Flags = Mods;
ModsBitField.KeyMod = Mods.Key1 | Mods.Key2 | Mods.Key3 | Mods.Key4 | Mods.Key5 | Mods.Key6 | Mods.Key7 | Mods.Key8 | Mods.Key9 | Mods.KeyCoop;
ModsBitField.FreeModAllowed = Mods.NoFail | Mods.Easy | Mods.Hidden | Mods.HardRock | Mods.SuddenDeath | Mods.Flashlight | Mods.FadeIn | Mods.Relax | Mods.AutoPilot | Mods.SpunOut | _ModsBitField.KeyMod;
ModsBitField.ScoreIncreaseMods = Mods.Hidden | Mods.HardRock | Mods.DoubleTime | Mods.Flashlight | Mods.FadeIn;

// src/utils/AccuracyCalculator.ts
var AccuracyCalculator = class {
  static standard(count300, count100, count50, countMiss) {
    const max = count300 + count100 + count50 + countMiss;
    if (!max)
      return 0;
    return (count300 * 300 + count100 * 100 + count50 * 50) / (max * 300);
  }
  static taiko(count300, count100, countMiss) {
    const max = count300 + count100 + countMiss;
    if (!max)
      return 0;
    return (count300 + count100 * 0.5) / max;
  }
  static catch(count300, count100, count50, countKatu, countMiss) {
    const max = count300 + count100 + count50 + countKatu + countMiss;
    if (!max)
      return 0;
    return (count300 + count100 + count50) / max;
  }
  static mania(count300, count100, count50, countKatu, countGeki, countMiss) {
    const max = count300 + count100 + count50 + countKatu + countGeki + countMiss;
    if (!max)
      return 0;
    return (300 * countGeki + 300 * count300 + 200 * countKatu + 100 * count100 + 50 * count50) / (max * 300);
  }
  static maniaV2(count300, count100, count50, countKatu, countGeki, countMiss) {
    const max = count300 + count100 + count50 + countKatu + countGeki + countMiss;
    if (!max)
      return 0;
    return (305 * countGeki + 300 * count300 + 200 * countKatu + 100 * count100 + 50 * count50) / (max * 305);
  }
  static calculate(score, v2 = false) {
    const { statistics } = score;
    switch (score.mode) {
      case 0 /* Standard */:
        return AccuracyCalculator.standard(
          statistics.count300,
          statistics.count100,
          statistics.count50,
          statistics.countMiss
        );
      case 1 /* Taiko */:
        return AccuracyCalculator.taiko(
          statistics.count300,
          statistics.count100,
          statistics.countMiss
        );
      case 2 /* Catch */:
        return AccuracyCalculator.catch(
          statistics.count300,
          statistics.count100,
          statistics.count50,
          statistics.countKatu,
          statistics.countMiss
        );
      case 3 /* Mania */:
        return v2 ? AccuracyCalculator.maniaV2(
          statistics.count300,
          statistics.count100,
          statistics.count50,
          statistics.countKatu,
          statistics.countGeki,
          statistics.countMiss
        ) : AccuracyCalculator.mania(
          statistics.count300,
          statistics.count100,
          statistics.count50,
          statistics.countKatu,
          statistics.countGeki,
          statistics.countMiss
        );
    }
  }
};

// src/structures/BaseScore.ts
var BaseScore = class {
  constructor(client, data, other) {
    this.client = client;
    this.score = +data.score;
    this.maxCombo = +data.maxcombo;
    this.statistics = {
      count50: +data.count50,
      count100: +data.count100,
      count300: +data.count300,
      countMiss: +data.countmiss,
      countKatu: +data.countkatu,
      countGeki: +data.countgeki
    };
    this.perfect = !!+data.perfect;
    this.enabledMods = new ModsBitField(data.enabled_mods);
    this.userId = data.user_id;
    this.rank = ScoreRank[data.rank];
    this.mode = other.mode ?? 0 /* Standard */;
    if ("beatmap_id" in data) {
      this.beatmapId = data.beatmap_id;
    } else {
      this.beatmapId = other.mapId;
    }
    this.accuracy = AccuracyCalculator.calculate(this);
  }
  async getPlayer(options = {}) {
    const candidates = await this.client.users.getUser({
      user: this.userId,
      type: "id" /* Id */,
      ...options
    });
    return candidates[0];
  }
  async getBeatmap() {
    const candidates = await this.client.beatmaps.getBeatmaps({
      beatmapId: this.beatmapId,
      mode: this.mode
    });
    return candidates[0];
  }
  getReplay() {
    return this.client.replays.getReplay({
      beatmapId: this.beatmapId,
      user: this.userId,
      type: "id" /* Id */
    });
  }
};

// src/structures/BeatmapScore.ts
var BeatmapScore = class extends BaseScore {
  constructor(client, data, other) {
    super(client, data, other);
    this.scoreId = null;
    this.username = null;
    this.pp = null;
    this.replayAvailable = null;
    this.date = new Date(data.date);
    if ("score_id" in data) {
      this.scoreId = data.score_id;
    }
    if ("username" in data) {
      this.username = data.username;
    }
    if ("pp" in data) {
      this.pp = +data.pp;
    }
    if ("replay_available" in data) {
      this.replayAvailable = !!+data.replay_available;
    }
  }
  scoreURL() {
    if (!this.scoreId)
      return null;
    return URLBuilder.scoreURL(this.mode, this.scoreId);
  }
};

// src/structures/UserEvent.ts
var UserEvent = class {
  constructor(user, data) {
    this.user = user;
    this.displayHtml = data.display_html;
    this.beatmapId = data.beatmap_id;
    this.beatmapsetId = data.beatmapset_id;
    this.date = new Date(data.date);
    this.epicfactor = +data.epicfactor;
  }
  async getBeatmap() {
    const candidates = await this.user.client.beatmaps.getBeatmaps({
      beatmapId: this.beatmapId,
      beatmapsetId: this.beatmapsetId
    });
    return candidates[0];
  }
  async getBeatmapset() {
    const beatmap = await this.getBeatmap();
    return beatmap?.getBeatmapset();
  }
};

// src/structures/User.ts
var User = class {
  constructor(client, data) {
    this.client = client;
    this.id = data.user_id;
    this.username = data.username;
    this.joinDate = new Date(data.join_date);
    this.count300 = +data.count300;
    this.count100 = +data.count100;
    this.count50 = +data.count50;
    this.playcount = +data.playcount;
    this.playtime = +data.total_seconds_played;
    this.rankedScore = +data.ranked_score;
    this.totalScore = +data.total_score;
    this.rank = +data.pp_rank;
    this.level = +data.level;
    this.pp = +data.pp_raw;
    this.accuracy = +data.accuracy;
    this.scoreRankCount = {
      ss: +data.count_rank_ss,
      ssh: +data.count_rank_ssh,
      s: +data.count_rank_s,
      sh: +data.count_rank_sh,
      a: +data.count_rank_a
    };
    this.country = data.country;
    this.countryRank = +data.pp_country_rank;
    this.events = data.events.map((v) => new UserEvent(this, v));
    this.banner = null;
  }
  avatarURL() {
    return URLBuilder.avatar(this.id);
  }
  profileURL() {
    return URLBuilder.profile(this.id);
  }
  async fetchBanner(force = false) {
    if (!force && this.banner)
      return this.banner;
    const url = await this.client.users.fetchBanner({ id: this.id });
    return this.banner = url;
  }
  getBest(options = {}) {
    return this.client.users.getUserBest({
      user: this.id,
      type: "id" /* Id */,
      ...options
    });
  }
  getRecent(options = {}) {
    return this.client.users.getUserRecent({
      user: this.id,
      type: "id" /* Id */,
      ...options
    });
  }
};

// src/managers/BaseManager.ts
var BaseManager = class {
  constructor(client) {
    this.client = client;
  }
};

// src/managers/UserManager.ts
var UserManager = class extends BaseManager {
  async getUser(options) {
    const queries = {
      u: options.user,
      m: options.gameMode,
      type: options.type,
      event_days: options.eventDays
    };
    const res = await this.client.request({
      path: "get_user",
      queries
    });
    return res.map((v) => new User(this.client, v));
  }
  async fetchBanner({ id }) {
    const context = await request.get(`https://osu.ppy.sh/users/${id}`);
    const banner_regex = new RegExp(`https:\\\\\\/\\\\\\/assets\\.ppy\\.sh\\\\\\/user-profile-covers\\\\\\/${id}\\\\\\/(?<hash>[0-9a-z]*?)\\.(?<ext>.*?)&`, "gm");
    const banner = banner_regex.exec(context.text);
    if (banner) {
      const url2 = URLBuilder.banner(id, banner?.groups?.hash, banner?.groups?.ext);
      return url2;
    }
    const default_banner_regex = new RegExp("https:\\\\\\/\\\\\\/osu\\.ppy\\.sh\\\\\\/images\\\\\\/headers\\\\\\/profile-covers\\\\\\/c(?<id>\\d)\\.(?<ext>.*?)&", "gm");
    const defaultBanner = default_banner_regex.exec(context.text);
    const url = URLBuilder.defaultBanner(defaultBanner?.groups?.id, defaultBanner?.groups?.ext);
    return url;
  }
  async getUserBest(options) {
    const queries = {
      u: options.user,
      m: options.mode,
      type: options.type,
      limit: options.limit
    };
    const res = await this.client.request({
      path: "get_user_best",
      queries
    });
    return res.map((v) => new BeatmapScore(this.client, v, { mode: options.mode }));
  }
  async getUserRecent(options) {
    const queries = {
      u: options.user,
      m: options.mode,
      type: options.type,
      limit: options.limit
    };
    const res = await this.client.request({
      path: "get_user_recent",
      queries
    });
    return res.map((v) => new BeatmapScore(this.client, v, { mode: options.mode }));
  }
};

// src/utils/toSqlDate.ts
function toSqlDate(date) {
  return date.toISOString().slice(0, 19).replace("T", " ");
}

// src/structures/Beatmapset.ts
var Beatmapset = class {
  constructor(client, data, maps) {
    this.client = client;
    this.beatmaps = maps;
    this.id = data.beatmapsetId;
    this.approvedState = data.approvedState;
    this.length = data.totalLength;
    this.submitDate = data.submitDate;
    this.approvedDate = data.approvedDate;
    this.lastUpdate = data.lastUpdate;
    this.artist = data.artist;
    this.title = data.title;
    this.creator = data.creator;
    this.creatorId = data.creatorId;
    this.source = data.source;
    this.tags = data.tags.slice();
    this.genre = data.genre;
    this.language = data.language;
    this.favoriteCount = data.favoriteCount;
    this.rating = data.rating;
    this.downloadUnavailable = data.downloadUnavailable;
    this.audioUnavailable = data.audioUnavailable;
  }
  beatmapsetURL() {
    return URLBuilder.beatmapsetURL(this.id);
  }
  coverImageURL() {
    return URLBuilder.beatmapCoverImage(this.id);
  }
  coverThumbnailURL() {
    return URLBuilder.beatmapCoverThumbnail(this.id);
  }
  async getCreator() {
    const candidates = await this.client.users.getUser({
      user: this.creatorId,
      type: "id" /* Id */
    });
    return candidates[0];
  }
};

// src/structures/Beatmap.ts
var Beatmap = class {
  constructor(client, data) {
    this.client = client;
    this.id = data.beatmap_id;
    this.beatmapsetId = data.beatmapset_id;
    this.approvedState = +data.approved;
    this.totalLength = +data.total_length;
    this.hitLength = +data.hit_length;
    this.diffcultyName = data.version;
    this.hash = data.file_md5;
    this.difficulty = {
      ApproachRate: +data.diff_approach,
      CircleSize: +data.diff_size,
      OverallDifficulty: +data.diff_overall,
      HPDrainRate: +data.diff_drain,
      aim: +(data.diff_aim ?? 0),
      speed: +(data.diff_speed ?? 0),
      rating: +(data.difficultyrating ?? 0)
    };
    this.mode = +data.mode;
    this.objectCount = {
      circle: +data.count_normal,
      slider: +data.count_slider,
      spinner: +data.count_spinner
    };
    this.submitDate = new Date(data.submit_date);
    if (!data.approved_date) {
      this.approvedDate = null;
    } else {
      this.approvedDate = new Date(data.approved_date);
    }
    this.lastUpdate = new Date(data.last_update);
    this.artist = data.artist;
    this.title = data.title;
    this.creator = data.creator;
    this.creatorId = data.creator_id;
    this.bpm = +data.bpm;
    this.source = data.source;
    this.tags = data.tags.split(" ");
    this.genre = +data.genre_id;
    this.language = +data.language_id;
    this.favoriteCount = +data.favourite_count;
    this.rating = +data.rating;
    this.downloadUnavailable = !!+data.download_unavailable;
    this.audioUnavailable = !!+data.audio_unavailable;
    this.playcount = +data.playcount;
    this.passcount = +data.passcount;
    if (data.max_combo) {
      this.maxCombo = +data.max_combo;
    } else {
      this.maxCombo = null;
    }
  }
  beatmapsetURL() {
    return URLBuilder.beatmapsetURL(this.beatmapsetId);
  }
  beatmapURL() {
    return URLBuilder.beatmapURL(this.beatmapsetId, this.id, this.mode);
  }
  coverImageURL() {
    return URLBuilder.beatmapCoverImage(this.beatmapsetId);
  }
  coverThumbnailURL() {
    return URLBuilder.beatmapCoverThumbnail(this.beatmapsetId);
  }
  async getCreator() {
    const candidates = await this.client.users.getUser({
      user: this.creatorId,
      type: "id" /* Id */
    });
    return candidates[0];
  }
  async getBeatmapset() {
    const set = await this.client.beatmaps.getBeatmaps({
      beatmapsetId: this.beatmapsetId
    });
    return new Beatmapset(this.client, this, set);
  }
};

// src/managers/BeatmapManager.ts
var BeatmapManager = class extends BaseManager {
  async getBeatmaps(options = {}) {
    const queries = {
      since: options.since && toSqlDate(options.since),
      s: options.beatmapsetId,
      b: options.beatmapId,
      u: options.user,
      type: options.type,
      m: options.mode,
      a: options.showConverted,
      h: options.hash,
      limit: options.limit,
      mods: ModsBitField.resolve(options.mods ?? 0)
    };
    const res = await this.client.request({
      path: "get_beatmaps",
      queries
    });
    return res.map((v) => new Beatmap(this.client, v));
  }
};

// src/managers/ScoreManager.ts
var ScoreManager = class extends BaseManager {
  async getScores(options) {
    const mods = options.mods == void 0 ? void 0 : ModsBitField.resolve(options.mods);
    const queries = {
      b: options.beatmapId,
      u: options.user,
      m: options.mode,
      mods,
      type: options.type,
      limit: options.limit
    };
    const res = await this.client.request({
      path: "get_scores",
      queries
    });
    return res.map((v) => new BeatmapScore(this.client, v, { mapId: options.beatmapId, mode: options.mode }));
  }
};

// src/structures/Replay.ts
import { Buffer } from "node:buffer";
var Replay = class {
  constructor(client, data) {
    this.client = client;
    this.content = data.content;
    this.stream = Buffer.from(this.content, "base64");
  }
};

// src/managers/ReplayManager.ts
var ReplayManager = class extends BaseManager {
  async getReplay(options) {
    if ((!options.beatmapId || !options.user) && !options.scoreId) {
      throw new Error("You should provide either beatmapId and user or scordId to get replay");
    }
    const mods = options.mods == void 0 ? void 0 : ModsBitField.resolve(options.mods);
    const queries = {
      b: options.beatmapId,
      u: options.user,
      m: options.mode,
      s: options.scoreId,
      type: options.type,
      mods
    };
    const res = await this.client.request({
      path: "get_replay",
      queries
    });
    return new Replay(this.client, res);
  }
};

// src/structures/MatchScore.ts
var MatchScore = class extends BaseScore {
  constructor(client, data, other) {
    super(client, data, other);
    this.slot = +data.slot;
    this.team = +data.team;
    this.pass = !!+data.pass;
  }
};

// src/structures/MatchGame.ts
var MatchGame = class {
  constructor(match, data) {
    this.client = match.client;
    this.match = match;
    this.id = data.game_id;
    this.startAt = new Date(data.start_time);
    this.endAt = new Date(data.end_time);
    this.beatmapId = data.beatmap_id;
    this.mode = +data.play_mode;
    this.matchType = +data.match_type;
    this.scoringType = +data.scoring_type;
    this.teamType = +data.team_type;
    this.mods = new ModsBitField(data.mods);
    this.scores = data.scores.map((score) => new MatchScore(this.client, score, {
      mode: +data.play_mode,
      mapId: data.beatmap_id
    }));
  }
  async getBeatmap() {
    const candidates = await this.client.beatmaps.getBeatmaps({
      beatmapId: this.beatmapId
    });
    return candidates[0];
  }
};

// src/structures/Match.ts
var Match = class {
  constructor(client, data) {
    this.client = client;
    const { match, games } = data;
    this.id = match.match_id;
    this.name = match.name;
    this.startAt = new Date(match.start_time);
    if (match.end_time) {
      this.endAt = new Date(match.end_time);
    } else {
      this.endAt = null;
    }
    this.games = games.map((data2) => new MatchGame(this, data2));
  }
};

// src/managers/MatchManager.ts
var MatchManager = class extends BaseManager {
  async getMatch(options) {
    const queries = {
      mp: options.matchId
    };
    const res = await this.client.request({
      path: "get_match",
      queries
    });
    if (res.match === 0) {
      return null;
    }
    return new Match(this.client, res);
  }
};

// src/Client.ts
var Client = class {
  constructor(options) {
    this.apiKey = options.apiKey;
    this.users = new UserManager(this);
    this.beatmaps = new BeatmapManager(this);
    this.scores = new ScoreManager(this);
    this.replays = new ReplayManager(this);
    this.matches = new MatchManager(this);
  }
  async request(options) {
    if (!options?.path)
      throw new Error("MISSING_PATH");
    const response = await request2.get(`https://osu.ppy.sh/api/${options.path}`).query({ k: this.apiKey }).query(options.queries);
    return response.body;
  }
};
export {
  AccuracyCalculator,
  BaseManager,
  BaseScore,
  Beatmap,
  BeatmapApprovedState,
  BeatmapGenre,
  BeatmapLanguage,
  BeatmapManager,
  BeatmapScore,
  Beatmapset,
  Client,
  GameMode,
  Match,
  MatchGame,
  MatchManager,
  MatchScore,
  MatchScoringType,
  MatchTeamType,
  Mods,
  ModsAbbreviation,
  ModsBitField,
  Replay,
  ReplayManager,
  ScoreManager,
  ScoreRank,
  Team,
  URLBuilder,
  User,
  UserEvent,
  UserManager,
  UserRequestType
};
//# sourceMappingURL=index.mjs.map